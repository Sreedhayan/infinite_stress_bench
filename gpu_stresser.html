<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Infinite Rotating Spherical Fractal — Heavy WebGL2</title>
<style>
  html,body{height:100%;margin:0;background:#000}
  canvas{display:block;width:100vw;height:100vh}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
// WARNING: This program intentionally ramps up GPU work indefinitely and is extremely heavy.
// It uses WebGL2 + fragment raymarching with time-based increasing iterations.
// If your browser freezes, close the tab. Run only on a machine you control.

const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl2',{antialias:false, preserveDrawingBuffer:false, powerPreference:'high-performance'});
if(!gl){ document.body.innerHTML = '<h2 style="color:white;padding:20px">WebGL2 required</h2>'; throw new Error('WebGL2 required'); }

function resize(){
  // intentionally choose very high backing resolution (devicePixelRatio * multiplier)
  const scale = Math.max(1.0, window.devicePixelRatio || 1) * 2.0; // 2x DPR multiplier for high-res
  const w = Math.floor(window.innerWidth * scale);
  const h = Math.floor(window.innerHeight * scale);
  if(canvas.width !== w || canvas.height !== h){
    canvas.width = w; canvas.height = h;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    gl.viewport(0,0,w,h);
  }
}
window.addEventListener('resize', resize);
resize();

const vs = `#version 300 es
precision highp float;
layout(location=0) in vec2 p;
void main(){ gl_Position = vec4(p,0.0,1.0); }
`;

// Heavy fragment shader: raymarch a distorted sphere with iterative displacement and fbm-style detail
const fs = `#version 300 es
precision highp float;
out vec4 outColor;
uniform vec2 u_res;
uniform float u_time;

// hash / noise
uint wang_hash(uint seed){ seed = (seed ^ 61u) ^ (seed >> 16u); seed *= 9u; seed = seed ^ (seed >> 4u); seed *= 0x27d4eb2du; seed = seed ^ (seed >> 15u); return seed; }
float rnd(inout uint seed){ return float(wang_hash(seed)) / 4294967296.0; }

// rotate
mat3 rotX(float a){ float s=sin(a), c=cos(a); return mat3(1,0,0, 0,c,-s, 0,s,c); }
mat3 rotY(float a){ float s=sin(a), c=cos(a); return mat3(c,0,s, 0,1,0, -s,0,c); }
mat3 rotZ(float a){ float s=sin(a), c=cos(a); return mat3(c,-s,0, s,c,0, 0,0,1); }

// smooth min
float smin(float a,float b,float k){ float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0); return mix(b,a,h) - k*h*(1.0-h); }

// sphere SDF
float sdSphere(vec3 p, float r){ return length(p) - r; }

// iterative displacement — increases complexity over time
float displace(vec3 p, float t){
  float acc = 0.0;
  // base frequency grows slowly over time
  float baseFreq = 1.0 + t*0.02;
  // number of layers increases with time (clamped to avoid infinite loop in shader compilation)
  int layers = int(4.0 + mod(t*0.6, 40.0));
  for(int i=0;i<60;i++){
    if(i>=layers) break;
    // rotate coordinates slightly per layer
    float a = float(i)*0.37 + t*0.08;
    vec3 q = p * (baseFreq * (1.0 + float(i)*0.12));
    q = (rotX(a) * rotY(a*0.71)) * q;
    // pseudo-noise using sin/cos mixing (cheap but heavy when repeated)
    float n = sin(q.x + sin(q.y*1.23 + cos(q.z*0.7))) + cos(q.y*1.7 + sin(q.z*0.3));
    acc += (n) * (0.5 / float(i+1));
  }
  return acc;
}

// map function: sphere + displacement creates intricate surface
float map(vec3 p, float t){
  float r = 1.0;
  float d = sdSphere(p, r);
  float disp = displace(p * 2.0, t) * 0.18; // displacement scale
  return d + disp;
}

// normal approximation
vec3 calcNormal(vec3 p, float t){
  float eps = 0.0008;
  vec3 e = vec3(eps,0,0);
  return normalize(vec3(
    map(p+e.xyy, t) - map(p-e.xyy, t),
    map(p+e.yxy, t) - map(p-e.yxy, t),
    map(p+e.yyx, t) - map(p-e.yyx, t)
  ));
}

// soft lighting
float softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k, float t){
  float res = 1.0; float h = 1.0;
  float ph = 1e20;
  for(int i=0;i<80;i++){
    float tm = mint + (maxt - mint) * (float(i)/79.0);
    vec3 pos = ro + rd * tm;
    float d = map(pos, t);
    h = d * 0.5 / tm;
    res = min(res, 20.0*h/(abs(h)+0.0001));
    if(res < 0.02) return 0.02;
  }
  return clamp(res, 0.02, 1.0);
}

void main(){
  vec2 uv = (gl_FragCoord.xy / u_res) * 2.0 - 1.0;
  uv.x *= u_res.x / u_res.y;

  // camera that orbits slowly
  float t = u_time * 0.6;
  vec3 camPos = vec3(0.0, 0.0, 4.0);
  mat3 camRot = rotY(t*0.2) * rotX(t*0.07);
  camPos = camRot * camPos;
  vec3 ro = camPos;
  vec3 rd = normalize(camRot * vec3(uv, -1.6));

  // raymarching
  float totalDist = 0.0;
  float d;
  float sceneDist = 100.0;
  int maxSteps = 120;

  // increase steps gradually over time (this makes complexity grow without user input)
  int extra = int(mod(u_time*0.7, 240.0));
  maxSteps += extra; // can grow large over time

  int i;
  for(i=0;i<maxSteps;i++){
    vec3 p = ro + rd * totalDist;
    d = map(p, u_time);
    totalDist += d * 0.85; // safety factor
    if(d < 0.0009) break;
    if(totalDist > sceneDist) break;
  }

  vec3 col = vec3(0.0);
  if(totalDist < sceneDist){
    vec3 pos = ro + rd * totalDist;
    vec3 n = calcNormal(pos, u_time);
    vec3 lightDir = normalize(vec3(0.5, 0.8, -0.6));
    float diff = clamp(dot(n, lightDir), 0.0, 1.0);
    float spec = pow(max(dot(reflect(-lightDir, n), -rd), 0.0), 64.0);

    // color by iterative layers and view
    float layerHue = 0.5 + 0.5 * sin(u_time*0.12 + length(pos)*2.0);
    vec3 base = vec3(0.4 + 0.6*layerHue, 0.2 + 0.8*(1.0-layerHue), 0.6);

    float sh = softShadow(pos + n*0.001, lightDir, 0.01, 6.0, 32.0, u_time);
    col = base * diff * sh + spec * vec3(1.0);

    // rim glow
    float rim = pow(1.0 - max(dot(n, -rd), 0.0), 2.0);
    col += rim * 0.22 * vec3(0.9,0.7,1.0);

    // amplify detail by sampling displacement again (fake ambient occlusion)
    float ao = clamp(1.0 - 0.5*abs(displace(pos*1.5, u_time)), 0.0, 1.0);
    col *= mix(0.6, 1.0, ao);
  }

  // tone mapping and gamma
  col = col / (col + vec3(1.0));
  col = pow(col, vec3(0.4545));

  outColor = vec4(col, 1.0);
}
`;

function compileShader(type, src){
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
    console.error(gl.getShaderInfoLog(s));
    throw new Error('Shader compile error');
  }
  return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compileShader(gl.VERTEX_SHADER, vs));
gl.attachShader(prog, compileShader(gl.FRAGMENT_SHADER, fs));
gl.bindAttribLocation(prog, 0, 'p');
gl.linkProgram(prog);
if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){
  console.error(gl.getProgramInfoLog(prog));
  throw new Error('Program link error');
}

// full-screen triangle
const quadBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
const quad = new Float32Array([-1,-1, 3,-1, -1,3]);
gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);

const u_res = gl.getUniformLocation(prog, 'u_res');
const u_time = gl.getUniformLocation(prog, 'u_time');

let start = performance.now();
function frame(){
  resize();
  gl.clearColor(0,0,0,1);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.useProgram(prog);
  gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);

  const now = performance.now();
  const t = (now - start) * 0.001;

  gl.uniform2f(u_res, canvas.width, canvas.height);
  gl.uniform1f(u_time, t);

  // draw
  gl.drawArrays(gl.TRIANGLES, 0, 3);
  // loop forever; complexity increases because shader increases steps with time
  requestAnimationFrame(frame);
}

frame();
</script>
</body>
</html>
